/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

'use strict';

const vscode = require('vscode');
const cp = require('child_process');

const CHECKLIST_FILENAME = 'AIDE_CHECKLIST.md';
const AIDE_DIRNAME = '.aide';
const STATE_FILENAME = 'state.json';
const EVENTS_FILENAME = 'events.log';
const SNAPSHOTS_DIRNAME = 'snapshots';
const SCHEMA_VERSION = 1;

function nowIso() {
	return new Date().toISOString();
}

function safeJsonParse(text, fallback) {
	try {
		return JSON.parse(text);
	} catch {
		return fallback;
	}
}

async function getWorkspaceRootUri() {
	const folders = vscode.workspace.workspaceFolders;
	if (!folders || folders.length === 0) {
		return null;
	}
	return folders[0].uri;
}

async function readFileText(uri) {
	const data = await vscode.workspace.fs.readFile(uri);
	return new TextDecoder('utf-8').decode(data);
}

async function writeFileText(uri, text) {
	const data = new TextEncoder().encode(text);
	await vscode.workspace.fs.writeFile(uri, data);
}

async function appendFileText(uri, text) {
	let existing = '';
	try {
		existing = await readFileText(uri);
	} catch {
		// ignore
	}
	await writeFileText(uri, existing + text);
}

async function openFile(uri) {
	const doc = await vscode.workspace.openTextDocument(uri);
	await vscode.window.showTextDocument(doc, { preview: false });
}

function defaultChecklistTemplate() {
	const today = new Date().toISOString().slice(0, 10);
	const lines = [
		'# AIDE Project Checklist',
		'',
		'> Single source of truth for roadmap/todo. Generated by AIDE.',
		'',
		`Started: ${today}`,
		'',
		'<!-- AIDE:BEGIN -->',
		'',
		'## Milestones',
		'',
		'- [ ] M1 - Setup & Tooling',
		'\t- [ ] TASK-001: Install toolchain (Node/Python)',
		'\t- [ ] TASK-002: Fork + build/watch + run dev instance',
		'\t- [ ] TASK-003: Create built-in extension skeleton (aide-checklist)',
		'',
		'- [ ] M2 - Checklist + Brain MVP',
		'\t- [ ] TASK-010: State sync + view',
		'\t- [ ] TASK-011: Mark done + snapshot',
		'',
		'## Current Task',
		'- TASK-003',
		'',
		'## Notes',
		'- Rules: patch-only edits, safe-first, no secrets in prompts.',
		'',
		'<!-- AIDE:END -->',
		''
	];
	return lines.join('\n');
}

async function ensureChecklistFile(rootUri) {
	const fileUri = vscode.Uri.joinPath(rootUri, CHECKLIST_FILENAME);
	try {
		await vscode.workspace.fs.stat(fileUri);
		return { fileUri, existed: true };
	} catch {
		// continue
	}
	await writeFileText(fileUri, defaultChecklistTemplate());
	return { fileUri, existed: false };
}

async function ensureAideDir(rootUri) {
	const aideDirUri = vscode.Uri.joinPath(rootUri, AIDE_DIRNAME);
	await vscode.workspace.fs.createDirectory(aideDirUri);

	const snapshotsDirUri = vscode.Uri.joinPath(aideDirUri, SNAPSHOTS_DIRNAME);
	await vscode.workspace.fs.createDirectory(snapshotsDirUri);

	return { aideDirUri, snapshotsDirUri };
}

function newStateObject(projectId) {
	return {
		schemaVersion: SCHEMA_VERSION,
		projectId,
		createdAt: nowIso(),
		lastSyncAt: null,
		tasks: {},
		meta: {
			notes: ''
		}
	};
}

async function ensureState(rootUri) {
	const { aideDirUri } = await ensureAideDir(rootUri);
	const stateUri = vscode.Uri.joinPath(aideDirUri, STATE_FILENAME);

	try {
		const text = await readFileText(stateUri);
		const parsed = safeJsonParse(text, null);
		if (parsed && typeof parsed === 'object') {
			return { stateUri, state: parsed };
		}
	} catch {
		// continue
	}

	const projectId = `aide-${Math.random().toString(16).slice(2)}-${Date.now()}`;
	const state = newStateObject(projectId);
	await writeFileText(stateUri, JSON.stringify(state, null, '\t') + '\n');
	return { stateUri, state };
}

async function logEvent(rootUri, event) {
	const { aideDirUri } = await ensureAideDir(rootUri);
	const eventsUri = vscode.Uri.joinPath(aideDirUri, EVENTS_FILENAME);
	const line = JSON.stringify({ ts: nowIso(), ...event }) + '\n';
	await appendFileText(eventsUri, line);
}

function parseTasksFromChecklist(text) {
	const re = /^(\s*[-*]\s+\[( |x|X)\]\s+)(TASK-\d+)\s*:\s*(.+)\s*$/gm;
	const tasks = [];
	let m;
	while ((m = re.exec(text)) !== null) {
		tasks.push({
			checked: m[2].toLowerCase() === 'x',
			id: m[3],
			title: m[4]
		});
	}
	return tasks;
}

function applyTaskChecksToChecklist(text, desired) {
	const re = /^(\s*[-*]\s+\[)( |x|X)(\]\s+)(TASK-\d+)(\s*:\s*.+)\s*$/gm;
	return text.replace(re, (full, a, chk, b, id, rest) => {
		if (Object.prototype.hasOwnProperty.call(desired, id)) {
			const want = desired[id] ? 'x' : ' ';
			return `${a}${want}${b}${id}${rest}`;
		}
		return full;
	});
}

async function readGitHead(rootFsPath) {
	return await new Promise((resolve) => {
		cp.execFile('git', ['rev-parse', 'HEAD'], { cwd: rootFsPath }, (err, stdout) => {
			if (err) {
				resolve(null);
				return;
			}
			resolve(String(stdout).trim() || null);
		});
	});
}

async function syncChecklistAndState(rootUri) {
	const { fileUri } = await ensureChecklistFile(rootUri);
	const { stateUri, state } = await ensureState(rootUri);

	const checklistText = await readFileText(fileUri);
	const tasks = parseTasksFromChecklist(checklistText);

	for (const t of tasks) {
		if (!state.tasks[t.id]) {
			state.tasks[t.id] = {
				id: t.id,
				title: t.title,
				status: t.checked ? 'done' : 'todo',
				createdAt: nowIso(),
				updatedAt: nowIso(),
				evidence: []
			};
		} else {
			state.tasks[t.id].title = t.title;
			state.tasks[t.id].updatedAt = nowIso();
			if (t.checked && state.tasks[t.id].status !== 'done') {
				state.tasks[t.id].status = 'done';
				state.tasks[t.id].evidence = state.tasks[t.id].evidence || [];
				state.tasks[t.id].evidence.push({ type: 'manual', ts: nowIso(), note: 'Checked in checklist' });
			}
		}
	}

	const desired = {};
	for (const id of Object.keys(state.tasks)) {
		desired[id] = state.tasks[id].status === 'done';
	}

	const patched = applyTaskChecksToChecklist(checklistText, desired);
	if (patched !== checklistText) {
		await writeFileText(fileUri, patched);
	}

	state.lastSyncAt = nowIso();
	await writeFileText(stateUri, JSON.stringify(state, null, '\t') + '\n');
	await logEvent(rootUri, { type: 'sync', tasksFound: tasks.length });

	return { fileUri, stateUri, state, tasksFound: tasks.length };
}

async function markTaskDone(rootUri, taskId, note) {
	const { stateUri, state } = await ensureState(rootUri);

	if (!state.tasks || !state.tasks[taskId]) {
		throw new Error(`Unknown task: ${taskId}`);
	}

	state.tasks[taskId].status = 'done';
	state.tasks[taskId].updatedAt = nowIso();
	state.tasks[taskId].evidence = state.tasks[taskId].evidence || [];
	state.tasks[taskId].evidence.push({ type: 'manual', ts: nowIso(), note: note || '' });

	await writeFileText(stateUri, JSON.stringify(state, null, '\t') + '\n');
	await logEvent(rootUri, { type: 'markDone', taskId });

	await syncChecklistAndState(rootUri);
}

async function captureSnapshot(rootUri) {
	const { state } = await ensureState(rootUri);
	const { snapshotsDirUri } = await ensureAideDir(rootUri);

	const head = await readGitHead(rootUri.fsPath);

	const payload = {
		ts: nowIso(),
		gitHead: head,
		state
	};

	const stamp = new Date().toISOString().replace(/[:.]/g, '-');
	const snapUri = vscode.Uri.joinPath(snapshotsDirUri, `snapshot-${stamp}.json`);
	await writeFileText(snapUri, JSON.stringify(payload, null, '\t') + '\n');

	await logEvent(rootUri, { type: 'snapshot', gitHead: head });

	return snapUri;
}

class TaskItem extends vscode.TreeItem {
	constructor(task, isDone) {
		super(`${task.id}: ${task.title}`, vscode.TreeItemCollapsibleState.None);
		this.id = task.id;
		this.description = isDone ? 'done' : 'todo';
		this.contextValue = isDone ? 'aideTaskDone' : 'aideTaskTodo';
		this.iconPath = isDone ? new vscode.ThemeIcon('check') : new vscode.ThemeIcon('circle-outline');
		this.tooltip = `${task.id}\n${task.title}\nstatus: ${isDone ? 'done' : 'todo'}`;
	}
}

class ChecklistTasksProvider {
	constructor(getRootUri) {
		this._getRootUri = getRootUri;
		this._onDidChangeTreeData = new vscode.EventEmitter();
		this.onDidChangeTreeData = this._onDidChangeTreeData.event;
	}

	refresh() {
		this._onDidChangeTreeData.fire();
	}

	async getTreeItem(element) {
		return element;
	}

	async getChildren() {
		const rootUri = await this._getRootUri();
		if (!rootUri) {
			return [];
		}

		const { state } = await ensureState(rootUri);
		const tasks = Object.values(state.tasks || {});
		tasks.sort((a, b) => String(a.id).localeCompare(String(b.id)));

		return tasks.map(t => new TaskItem(t, t.status === 'done'));
	}
}

async function maybeAutoInit() {
	const rootUri = await getWorkspaceRootUri();
	if (!rootUri) {
		return;
	}

	const cfg = vscode.workspace.getConfiguration('aide.checklist');
	const autoInit = cfg.get('autoInit', true);
	if (!autoInit) {
		return;
	}

	const { aideDirUri } = await ensureAideDir(rootUri);
	const stateUri = vscode.Uri.joinPath(aideDirUri, STATE_FILENAME);

	let hasState = true;
	try {
		await vscode.workspace.fs.stat(stateUri);
	} catch {
		hasState = false;
	}

	if (!hasState) {
		await ensureState(rootUri);

		const autoCreateChecklist = cfg.get('autoCreateChecklist', false);
		if (autoCreateChecklist) {
			await ensureChecklistFile(rootUri);
			await syncChecklistAndState(rootUri);
		}

		vscode.window.setStatusBarMessage('AIDE initialized for this workspace.', 3000);
		await logEvent(rootUri, { type: 'autoInit', createdChecklist: !!autoCreateChecklist });
	}
}

/**
 * @param {vscode.ExtensionContext} context
 */
function activate(context) {
	const provider = new ChecklistTasksProvider(getWorkspaceRootUri);
	context.subscriptions.push(vscode.window.registerTreeDataProvider('aideChecklist.tasks', provider));

	const initCmd = vscode.commands.registerCommand('aide.checklist.init', async () => {
		const rootUri = await getWorkspaceRootUri();
		if (!rootUri) {
			vscode.window.showErrorMessage('AIDE: Please open a folder/workspace first.');
			return;
		}
		const res = await ensureChecklistFile(rootUri);
		await ensureState(rootUri);
		await syncChecklistAndState(rootUri);
		await openFile(res.fileUri);
		provider.refresh();
		vscode.window.showInformationMessage(res.existed ? 'AIDE checklist synced.' : 'AIDE checklist created and synced.');
	});

	const openCmd = vscode.commands.registerCommand('aide.checklist.open', async () => {
		const rootUri = await getWorkspaceRootUri();
		if (!rootUri) {
			vscode.window.showErrorMessage('AIDE: Please open a folder/workspace first.');
			return;
		}
		const fileUri = vscode.Uri.joinPath(rootUri, CHECKLIST_FILENAME);
		try {
			await vscode.workspace.fs.stat(fileUri);
			await openFile(fileUri);
		} catch {
			vscode.window.showWarningMessage('AIDE_CHECKLIST.md not found. Run: "AIDE: Init Checklist".');
		}
	});

	const syncCmd = vscode.commands.registerCommand('aide.checklist.sync', async () => {
		const rootUri = await getWorkspaceRootUri();
		if (!rootUri) {
			vscode.window.showErrorMessage('AIDE: Please open a folder/workspace first.');
			return;
		}
		const r = await syncChecklistAndState(rootUri);
		provider.refresh();
		vscode.window.setStatusBarMessage(`AIDE synced (tasks: ${r.tasksFound}).`, 3000);
	});

	const markDoneCmd = vscode.commands.registerCommand('aide.checklist.markDone', async () => {
		const rootUri = await getWorkspaceRootUri();
		if (!rootUri) {
			vscode.window.showErrorMessage('AIDE: Please open a folder/workspace first.');
			return;
		}

		const { state } = await ensureState(rootUri);
		const taskIds = Object.keys(state.tasks || {}).sort();
		if (taskIds.length === 0) {
			vscode.window.showWarningMessage('AIDE: No tasks found. Run "AIDE: Sync Checklist" first.');
			return;
		}

		const pick = await vscode.window.showQuickPick(taskIds.map(id => {
			const t = state.tasks[id];
			const label = `${id} (${t.status === 'done' ? 'done' : 'todo'})`;
			return { label, id };
		}), { placeHolder: 'Select a task to mark done' });

		if (!pick) {
			return;
		}

		const note = await vscode.window.showInputBox({ prompt: 'Optional note/evidence (stored in .aide/state.json)', value: '' });
		await markTaskDone(rootUri, pick.id, note || '');
		provider.refresh();
		vscode.window.showInformationMessage(`AIDE marked ${pick.id} as done.`);
	});

	const snapshotCmd = vscode.commands.registerCommand('aide.checklist.snapshot', async () => {
		const rootUri = await getWorkspaceRootUri();
		if (!rootUri) {
			vscode.window.showErrorMessage('AIDE: Please open a folder/workspace first.');
			return;
		}
		const snapUri = await captureSnapshot(rootUri);
		provider.refresh();
		await openFile(snapUri);
		vscode.window.showInformationMessage('AIDE snapshot captured.');
	});

	const refreshCmd = vscode.commands.registerCommand('aide.checklist.refreshView', async () => {
		provider.refresh();
	});

	context.subscriptions.push(initCmd, openCmd, syncCmd, markDoneCmd, snapshotCmd, refreshCmd);

	// Watch for state/checklist changes and refresh view.
	(async () => {
		const rootUri = await getWorkspaceRootUri();
		if (!rootUri) {
			return;
		}

		const statePattern = new vscode.RelativePattern(rootUri, `${AIDE_DIRNAME}/${STATE_FILENAME}`);
		const checklistPattern = new vscode.RelativePattern(rootUri, CHECKLIST_FILENAME);

		const w1 = vscode.workspace.createFileSystemWatcher(statePattern);
		const w2 = vscode.workspace.createFileSystemWatcher(checklistPattern);

		w1.onDidChange(() => provider.refresh());
		w1.onDidCreate(() => provider.refresh());
		w1.onDidDelete(() => provider.refresh());

		w2.onDidChange(() => provider.refresh());
		w2.onDidCreate(() => provider.refresh());
		w2.onDidDelete(() => provider.refresh());

		context.subscriptions.push(w1, w2);
	})();

	// Auto-init (local only).
	void maybeAutoInit();
}

function deactivate() {}

module.exports = { activate, deactivate };
